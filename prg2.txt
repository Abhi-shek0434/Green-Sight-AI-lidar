# Install required packages
!pip install opencv-python matplotlib Pillow scikit-image

import cv2
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import os
from google.colab import files
from google.colab.patches import cv2_imshow
import io
import IPython.display as display
from skimage import feature, filters, measure
from sklearn.cluster import KMeans

print("âœ… Advanced Forest Type Classifier for Google Colab")
print("=" * 60)

def extract_forest_features(image_path, mask):
    """
    Extract advanced features for forest type classification
    """
    original_image = cv2.imread(image_path)
    original_image_rgb = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)

    # Apply mask to get only forest areas
    forest_area = cv2.bitwise_and(original_image_rgb, original_image_rgb, mask=mask)

    # Convert to different color spaces
    hsv = cv2.cvtColor(forest_area, cv2.COLOR_RGB2HSV)
    lab = cv2.cvtColor(forest_area, cv2.COLOR_RGB2LAB)

    # Extract color features
    features = {}

    # RGB statistics
    for i, channel in enumerate(['Red', 'Green', 'Blue']):
        channel_data = forest_area[:, :, i]
        channel_data = channel_data[channel_data > 0]  # Only forest pixels
        if len(channel_data) > 0:
            features[f'{channel}_mean'] = np.mean(channel_data)
            features[f'{channel}_std'] = np.std(channel_data)
            features[f'{channel}_range'] = np.ptp(channel_data)

    # HSV statistics (important for vegetation)
    hue_channel = hsv[:, :, 0]
    hue_channel = hue_channel[hue_channel > 0]
    if len(hue_channel) > 0:
        features['Hue_mean'] = np.mean(hue_channel)
        features['Hue_std'] = np.std(hue_channel)
        features['Saturation_mean'] = np.mean(hsv[:, :, 1][hsv[:, :, 1] > 0])

    # Texture features using GLCM
    gray_forest = cv2.cvtColor(forest_area, cv2.COLOR_RGB2GRAY)
    gray_forest = gray_forest[gray_forest > 0]

    if len(gray_forest) > 0:
        # Calculate texture features
        try:
            glcm = feature.graycomatrix(gray_forest.astype(np.uint8), [1], [0], symmetric=True, normed=True)
            features['Contrast'] = feature.graycoprops(glcm, 'contrast')[0, 0]
            features['Homogeneity'] = feature.graycoprops(glcm, 'homogeneity')[0, 0]
            features['Energy'] = feature.graycoprops(glcm, 'energy')[0, 0]
            features['Correlation'] = feature.graycoprops(glcm, 'correlation')[0, 0]
        except:
            features.update({'Contrast': 0, 'Homogeneity': 0, 'Energy': 0, 'Correlation': 0})

    # Density and distribution features
    forest_pixels = np.count_nonzero(mask)
    total_pixels = mask.shape[0] * mask.shape[1]
    features['Density'] = forest_pixels / total_pixels

    # Canopy texture (using edge detection)
    edges = filters.sobel(gray_forest.astype(float)) if len(gray_forest) > 0 else 0
    features['Edge_density'] = np.mean(edges) if len(gray_forest) > 0 else 0

    # Color diversity (number of dominant colors)
    dominant_colors = extract_dominant_colors(forest_area)
    features['Color_variety'] = len(dominant_colors)

    return features

def extract_dominant_colors(image, n_colors=5):
    """Extract dominant colors using K-means clustering"""
    pixels = image.reshape(-1, 3)
    pixels = pixels[np.any(pixels > 0, axis=1)]  # Remove black pixels

    if len(pixels) > n_colors:
        kmeans = KMeans(n_clusters=n_colors, random_state=42)
        kmeans.fit(pixels)
        return kmeans.cluster_centers_
    return []

def classify_forest_type(features, percentage):
    """
    Classify forest type based on extracted features
    """
    scores = {
        'Tropical Forests': 0,
        'Temperate Forests': 0,
        'Boreal Forests': 0,
        'Montane Forests': 0,
        'Mangrove Forests': 0,
        'Dry Forests': 0,
        'Plantation Forests': 0
    }

    # Feature-based scoring system
    green_ratio = features.get('Green_mean', 0) / (features.get('Red_mean', 1) + features.get('Blue_mean', 1) + 0.001)
    color_variety = features.get('Color_variety', 0)
    texture_complexity = features.get('Contrast', 0) + features.get('Homogeneity', 0)
    density = features.get('Density', 0)

    # Tropical Forests (high biodiversity, dense, vibrant green)
    if green_ratio > 1.2 and color_variety >= 4 and texture_complexity > 0.3:
        scores['Tropical Forests'] += 3
    if density > 0.7:
        scores['Tropical Forests'] += 2

    # Temperate Forests (moderate green, seasonal variation)
    if 0.8 <= green_ratio <= 1.2 and 3 <= color_variety <= 5:
        scores['Temperate Forests'] += 3
    if 0.4 <= density <= 0.8:
        scores['Temperate Forests'] += 1

    # Boreal Forests (darker green, coniferous, less variety)
    if green_ratio < 0.8 and color_variety <= 3:
        scores['Boreal Forests'] += 3
    if features.get('Blue_mean', 0) > 100:  # Often bluish tint
        scores['Boreal Forests'] += 1

    # Montane Forests (variable, often mixed with rocks)
    if 0.3 <= density <= 0.6 and texture_complexity > 0.4:
        scores['Montane Forests'] += 2
    if features.get('Edge_density', 0) > 0.1:  # Rugged terrain
        scores['Montane Forests'] += 1

    # Mangrove Forests (distinct green-blue, coastal)
    if features.get('Blue_mean', 0) > 120 and features.get('Green_mean', 0) > 120:
        scores['Mangrove Forests'] += 3
    if green_ratio > 1.0 and features.get('Saturation_mean', 0) < 100:
        scores['Mangrove Forests'] += 1

    # Dry Forests (yellowish-green, sparse)
    if green_ratio < 0.7 and density < 0.5:
        scores['Dry Forests'] += 3
    if features.get('Red_mean', 0) > features.get('Green_mean', 0) * 0.8:
        scores['Dry Forests'] += 1

    # Plantation Forests (uniform, geometric patterns)
    if texture_complexity < 0.2 and color_variety <= 2:
        scores['Plantation Forests'] += 3
    if features.get('Homogeneity', 0) > 0.8:  # Very uniform
        scores['Plantation Forests'] += 2

    # Adjust scores based on coverage percentage
    for forest_type in scores:
        if percentage > 70 and forest_type in ['Tropical Forests', 'Boreal Forests']:
            scores[forest_type] += 2
        elif percentage < 30 and forest_type in ['Dry Forests', 'Montane Forests']:
            scores[forest_type] += 2

    # Get the best match
    best_type = max(scores.items(), key=lambda x: x[1])

    # Confidence calculation
    total_score = sum(scores.values())
    confidence = (best_type[1] / total_score * 100) if total_score > 0 else 0

    return best_type[0], confidence, scores

def analyze_forest_coverage(image_path):
    """
    Enhanced forest analysis with type classification
    """
    try:
        # Load the image
        original_image = cv2.imread(image_path)

        if original_image is None:
            print(f"Error: Could not load image from {image_path}")
            return None, None, None, None

        # Convert to HSV color space for better color segmentation
        hsv = cv2.cvtColor(original_image, cv2.COLOR_BGR2HSV)

        # Define range for green colors (forest/vegetation)
        lower_green = np.array([25, 40, 40])
        upper_green = np.array([95, 255, 255])

        # Create mask for green areas
        mask = cv2.inRange(hsv, lower_green, upper_green)

        # Apply morphological operations to clean up the mask
        kernel = np.ones((5,5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

        # Calculate percentage of forest coverage
        total_pixels = mask.shape[0] * mask.shape[1]
        forest_pixels = np.count_nonzero(mask)
        forest_percentage = (forest_pixels / total_pixels) * 100

        # Extract features for classification
        features = extract_forest_features(image_path, mask)

        # Classify forest type
        forest_type, confidence, type_scores = classify_forest_type(features, forest_percentage)

        # Create the processed image with green overlay for forest areas
        processed_image = original_image.copy()
        green_overlay = np.zeros_like(original_image)
        green_overlay[:] = [0, 255, 0]  # Green color

        # Apply green overlay to forest areas
        for i in range(3):
            processed_image[:,:,i] = np.where(mask > 0,
                                            original_image[:,:,i] * 0.7 + green_overlay[:,:,i] * 0.3,
                                            original_image[:,:,i])

        return processed_image, forest_percentage, mask, forest_type, confidence, features, type_scores

    except Exception as e:
        print(f"An error occurred during analysis: {str(e)}")
        return None, None, None, None, None, None, None

def display_forest_type_results(original_image_path, processed_image, percentage, mask,
                              forest_type, confidence, features, type_scores):
    """Display comprehensive analysis results with forest type classification"""

    # Load original image for display
    original_image = cv2.imread(original_image_path)
    original_image_rgb = cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB)
    processed_image_rgb = cv2.cvtColor(processed_image, cv2.COLOR_BGR2RGB)

    # Create a comprehensive visualization
    fig = plt.figure(figsize=(20, 12))

    # 1. Original Image
    plt.subplot(2, 3, 1)
    plt.imshow(original_image_rgb)
    plt.title('Original Image', fontsize=12, fontweight='bold')
    plt.axis('off')

    # 2. Processed Image (Forest Detection)
    plt.subplot(2, 3, 2)
    plt.imshow(processed_image_rgb)
    plt.title('Forest Detection (Green = Forest Areas)', fontsize=12, fontweight='bold')
    plt.axis('off')

    # 3. Forest Mask
    plt.subplot(2, 3, 3)
    plt.imshow(mask, cmap='Greens')
    plt.title('Forest Mask (White = Forest)', fontsize=12, fontweight='bold')
    plt.axis('off')

    # 4. Coverage Pie Chart
    plt.subplot(2, 3, 4)
    labels = ['Forest', 'Non-Forest']
    sizes = [percentage, 100 - percentage]
    colors = ['#2e8b57', '#ff6b6b']
    plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
    plt.title('Forest Coverage', fontsize=12, fontweight='bold')

    # 5. Forest Type Classification
    plt.subplot(2, 3, 5)
    forest_types = list(type_scores.keys())
    scores = list(type_scores.values())

    # Create colored bars based on confidence
    colors = ['lightgray' if score < max(scores) else '#2e8b57' for score in scores]
    bars = plt.barh(forest_types, scores, color=colors, alpha=0.7)
    plt.xlabel('Classification Score')
    plt.title('Forest Type Classification Scores', fontsize=12, fontweight='bold')
    plt.tight_layout()

    # 6. Feature Visualization
    plt.subplot(2, 3, 6)
    feature_names = ['Green_Ratio', 'Color_Variety', 'Texture_Complexity', 'Density']
    feature_values = [
        features.get('Green_mean', 0) / (features.get('Red_mean', 1) + 0.001),
        features.get('Color_variety', 0),
        features.get('Contrast', 0) + features.get('Homogeneity', 0),
        features.get('Density', 0) * 10  # Scale for visualization
    ]

    plt.bar(feature_names, feature_values, color=['blue', 'green', 'orange', 'red'], alpha=0.7)
    plt.title('Key Classification Features', fontsize=12, fontweight='bold')
    plt.xticks(rotation=45)

    plt.tight_layout()
    plt.show()

    # Print detailed results
    print("\n" + "="*70)
    print("ðŸŒ³ FOREST TYPE CLASSIFICATION RESULTS")
    print("="*70)
    print(f"ðŸ“Š Forest Coverage: {percentage:.2f}%")
    print(f"ðŸŽ¯ Classified Forest Type: {forest_type}")
    print(f"âœ… Confidence Level: {confidence:.1f}%")
    print(f"ðŸ“ Image Dimensions: {original_image.shape[1]} x {original_image.shape[0]} pixels")

    print("\nðŸ” Key Features Analysis:")
    print(f"   â€¢ Green Dominance Ratio: {features.get('Green_mean', 0) / (features.get('Red_mean', 1) + 0.001):.2f}")
    print(f"   â€¢ Color Variety: {features.get('Color_variety', 0)} dominant colors")
    print(f"   â€¢ Texture Complexity: {features.get('Contrast', 0) + features.get('Homogeneity', 0):.3f}")
    print(f"   â€¢ Forest Density: {features.get('Density', 0) * 100:.1f}%")

    print("\nðŸ“ˆ Classification Scores:")
    for forest_type, score in sorted(type_scores.items(), key=lambda x: x[1], reverse=True):
        indicator = "ðŸŽ¯" if score == max(type_scores.values()) else "  "
        print(f"   {indicator} {forest_type}: {score:.1f}")

    print("="*70)

def analyze_single_image():
    """Analyze a single uploaded image with forest type classification"""
    image_paths = upload_image()

    if not image_paths:
        print("âŒ No images uploaded!")
        return

    for image_path in image_paths:
        print(f"\nðŸ” Analyzing: {image_path}")

        result = analyze_forest_coverage(image_path)
        processed_image, percentage, mask, forest_type, confidence, features, type_scores = result

        if all(x is not None for x in [processed_image, percentage, mask, forest_type]):
            display_forest_type_results(image_path, processed_image, percentage, mask,
                                      forest_type, confidence, features, type_scores)

            # Save results
            output_filename = f"classified_{image_path}"
            cv2.imwrite(output_filename, processed_image)
            print(f"ðŸ’¾ Results saved as: {output_filename}")
        else:
            print(f"âŒ Failed to analyze {image_path}")

def upload_image():
    """Upload image files to Colab"""
    print("ðŸ“ Please upload your forest image(s):")
    uploaded = files.upload()

    image_paths = []
    for filename in uploaded.keys():
        print(f"âœ… Uploaded: {filename}")
        image_paths.append(filename)

    return image_paths

def show_forest_type_guide():
    """Display guide to forest type characteristics"""
    print("\n" + "="*70)
    print("ðŸŒ¿ FOREST TYPE CHARACTERISTICS GUIDE")
    print("="*70)

    guide = {
        'Tropical Forests': {
            'color': 'Vibrant green, high saturation',
            'texture': 'Very complex, high biodiversity',
            'density': 'Very dense (70-100% coverage)',
            'features': 'Multiple canopy layers, diverse colors'
        },
        'Temperate Forests': {
            'color': 'Moderate green, seasonal variation',
            'texture': 'Moderate complexity',
            'density': 'Medium density (40-80% coverage)',
            'features': 'Mixed deciduous/coniferous, uniform texture'
        },
        'Boreal Forests': {
            'color': 'Dark green to blue-green',
            'texture': 'Simple, uniform',
            'density': 'Medium to high density',
            'features': 'Coniferous trees, often snowy background'
        },
        'Montane Forests': {
            'color': 'Variable, mixed with terrain',
            'texture': 'Rugged, irregular',
            'density': 'Variable (30-70% coverage)',
            'features': 'Mountainous terrain, mixed vegetation'
        },
        'Mangrove Forests': {
            'color': 'Distinct green-blue',
            'texture': 'Unique water-vegetation mix',
            'density': 'Medium density',
            'features': 'Coastal areas, water visible'
        },
        'Dry Forests': {
            'color': 'Yellowish-green, sparse',
            'texture': 'Simple, low complexity',
            'density': 'Low density (<50% coverage)',
            'features': 'Sparse vegetation, more soil visible'
        },
        'Plantation Forests': {
            'color': 'Uniform green',
            'texture': 'Very uniform, geometric',
            'density': 'High but uniform',
            'features': 'Straight rows, single species'
        }
    }

    for forest_type, characteristics in guide.items():
        print(f"\nðŸŒ³ {forest_type}:")
        for char, desc in characteristics.items():
            print(f"   â€¢ {char.capitalize()}: {desc}")

# Update main function
def main():
    """Main function with enhanced menu"""
    while True:
        print("\n" + "="*50)
        print("ðŸŒ³ ADVANCED FOREST TYPE CLASSIFIER")
        print("="*50)
        print("1. ðŸ“· Analyze Single Image (with Type Classification)")
        print("2. ðŸŒ¿ View Forest Type Characteristics Guide")
        print("3. ðŸšª Exit")

        choice = input("\nEnter your choice (1-3): ").strip()

        if choice == '1':
            analyze_single_image()
        elif choice == '2':
            show_forest_type_guide()
        elif choice == '3':
            print("ðŸ‘‹ Thank you for using Advanced Forest Type Classifier!")
            break
        else:
            print("âŒ Invalid choice! Please try again.")

# Run the application
if __name__ == "__main__":
    main()